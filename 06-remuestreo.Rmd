# Intervalos de confianza y remuestreo

```{r setup, include=FALSE, message=FALSE}
library(tidyverse)
library(patchwork)
source("R/funciones_auxiliares.R")
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning=FALSE, fig.align = 'center')
comma <- function(x) format(x, digits = 2, big.mark = ",")
theme_set(theme_minimal())
```

En la sección anterior, vimos el concepto de distribución de muestreo
de una estadística que queremos utilizar para estimar un valor poblacional, y
vimos que con esta distribución podíamos evaluar **qué tan preciso es nuestro
estimador** evaluando qué tan concentrada está esta distribución alrededor
del valor poblacion que queremos estimar.

Sin embargo, en los ejemplos que vimos la población era conocida: ya sea
que tuviéramos toda la población finita disponible (como el ejemplo de las casas),
o donde la población estaba definida por un modelo teórico de probabilidad
(como los ejemplos de las distribuciones uniforme o exponencial).

Ahora vemos qué hacer en el caso que realmente nos interesa: solo tenemos
una muestra disponible, y la población es desconocida. Todo lo que tenemos
es una muestra y una estimación basada en la muestra, y requerimos estimar
la distribución de muestreo de la estadística de interés. El enfoque
que presentaremos aquí es uno de los más flexibles y poderosos que están
disponible para este problema: el método **bootstrap** o de **remuestreo**.

En primer lugar explicamos el concepto de intervalo de confianza, que es una
manera resumida de evaluar la precisión de nuestras estimaciones.


## Ejemplo introductorio {-}

Regresamos a nuestro ejemplo anterior donde muestreamos 3 grupos, y nos preguntábamos
acerca de la diferencia de sus medianas. En lugar de hacer pruebas de permutaciones 
(ya sea pruebas gráficas o alguna prueba de permutaciones para media o mediana, por ejemplo),
podríamos considerar qué tan precisa es cada una de nuestras estimaciones
para las medianas de los grupos.

Nuestros resultados podríamos presentarlos como sigue. Este código lo explicaremos
más adelante, por el momento consideramos la gŕafica resultante:

```{r, message = FALSE, cache = TRUE}
set.seed(8)
pob_tab <- tibble(id = 1:2000, x = rgamma(2000, 4, 1), 
    grupo = sample(c("a","b", "c"), 2000, prob = c(4,2,1), replace = T))
muestra_tab <- pob_tab %>% sample_n(125)
g_1 <- ggplot(muestra_tab, aes(x = grupo, y = x)) + geom_boxplot(outlier.alpha = 0) +
    geom_jitter(alpha = 0.3) + 
      labs(subtitle = "Muestra \n") + ylim(c(0,14))
## Hacemos bootstrap
fun_boot <- function(datos){
    datos %>% group_by(grupo) %>% sample_n(n(), replace = TRUE)
}
reps_boot <- map(1:2000, function(i){
    medianas <- muestra_tab %>% 
        fun_boot %>% 
        group_by(grupo) %>% 
        summarise(mediana = median(x), .groups = "drop")
    medianas %>% mutate(rep = i)
}) %>% bind_rows
resumen_boot <- reps_boot %>% group_by(grupo) %>% 
    summarise(ymin = quantile(mediana, 0.025), ymax = quantile(mediana, 0.975)) %>% 
    left_join(muestra_tab %>% group_by(grupo) %>% summarise(mediana = median(x)))
g_2 <- ggplot(resumen_boot, aes(x = grupo, y = mediana, ymin = ymin, ymax = ymax)) +
    geom_linerange() +
    geom_point(colour = "red", size = 2) +  ylim(c(0,14)) +
    labs(subtitle = "Intervalos de 95% \n para la mediana")
g_1 + g_2
```

Donde: 

- En rojo está nuestro estimador puntual de la mediana de cada
grupo (la mediana muestral), y
- Las segmentos muestran un intervalo de confianza del 95\% 
para nuestra estimación de la mediana: esto quiere decir que 
los valores poblacionales tienen probabilidad aproximada de 95\% de estar
dentro del intervalo.

Este análisis comunica correctamente que tenemos **incertidumbre** alta acerca de nuestras
estimaciones (especialmente grupos b y c), y que no tenemos mucha evidencia de que el 
grupo b tenga una mediana poblacional considerablemente más alta que a o c. **En muchos casos
es más útil presentar la información de esta manera que usando alguna prueba
de hipótesis.**



## La idea del bootstrap {-}


Como explicamos, el problema que tenemos ahora es que normalmente sólo tenemos una muestra, 
así que
no es posible calcular las distribuciones de muestreo como hicimos arriba y evaluar
qué tan preciso es nuestro estimador. Sin embargo,
podemos hacer lo siguiente:

Supongamos que tenemos una muestra $X_1,X_2,\dots, X_n$ independientes de alguna
población desconocida y un estimador $T=t(X_1,\dots, X_n)$

**Mundo poblacional**

1. Si tuviéramos la distribución poblacional, simulamos muestras iid para aproximar
la distribución de muestreo de nuestro estimador, y así entender su variabilidad.
2. Pero **no** tenemos la distribución poblacional
3. **Sin embargo, podemos estimar la distribución poblacional con nuestros valores muestrales**

**Mundo bootstrap**

4. Si usamos la estimación del inciso 3, entonces usando el inciso 1 podríamos tomar muestras
de nuestros datos muestrales, como si fueran de la población, y usando el mismo tamaño de muestra. El muestreo lo hacemos con reemplazo de manera que produzcamos muestras independientes de la misma "población estimada", que es la muestra.
5. Evaluamos nuestra estadística en cada una de estas remuestras.
6. A la distribución resultante le llamamos **distribución bootstrap** o **distribución de remuestreo** del estimador
7. Usamos la distribución bootstrap de la muestra para estimar la variabilidad en nuestra
estimación con **la muestra original**.


Veamos que sucede para un ejemplo concreto, donde  nos interesa estimar
la media de los precios de venta de una población de casas. Tenemos nuestra muestra:

```{r, cache=TRUE}
set.seed(2112)
poblacion_casas <- read_csv("data/casas.csv")
muestra <- sample_n(poblacion_casas, 200, replace = TRUE)
mean(muestra$precio_miles)
```

Esta muestra nos da nuestro estimador de la distribución poblacional:

```{r,  fig.width =5, fig.height = 3}
bind_rows(muestra %>% mutate(tipo = "muestra"),
    poblacion_casas %>% mutate(tipo = "población")) %>% 
ggplot(aes(sample = precio_miles, colour = tipo, group = tipo)) + 
    geom_qq(distribution = stats::qunif, alpha = 0.4, size = 1) +
  facet_wrap(~ tipo)
```

O con histogramas:

```{r,  fig.width =5, fig.height = 3}
bind_rows(muestra %>% mutate(tipo = "muestra"),
    poblacion_casas %>% mutate(tipo = "población")) %>% 
ggplot(aes(x = precio_miles, group = tipo)) + 
    geom_histogram(aes(y=..density..), binwidth = 50) + 
    facet_wrap(~ tipo)
```

Y vemos que la aproximación es razonable en las partes centrales de la 
distribución. 

Ahora supongamos que nos interesa cuantificar la precisión de nuestra
estimación de la media poblacional de precios de casas, y usaremos la media
muestral para hacer esto. Para nuestra muestra, nuestra estimación puntual es:

```{r}
media <- mean(muestra$precio_miles)
media
```


Y recordamos que para aproximar la distribución de muestreo
podíamos muestrear repetidamente la población y calcular el valor del
estimador en cada una de estas muestras. Aquí no tenemos la población,
**pero tenemos una estimación de la población**: la muestra obtenida.

Así que para 
evaluar la variabilidad de nuestro estimador, entramos en el
mundo boostrap, y consideramos que la población es nuestra muestra.

Podemos entonces extraer un número
grande de muestras con reemplazo de tamaño 200 **de la muestra**: el muestreo
debe ser análogo al que se tomó para nuestra muestra original. Evaluamos nuestra
estadística (en este caso la media) en cada una de estas remuestras:

```{r, cache = TRUE}
media_muestras <- map_dbl(1:5000, ~ muestra %>%  
    sample_n(200, replace = T) %>%
    summarise(media_precio = mean(precio_miles)) %>% pull(media_precio)) 
```

Y nuestra estimación de la distribución de muestreo para la media es entonces:

```{r, fig.width =6, fig.height = 4}
bootstrap <- tibble(media = media_muestras)
g_cuantiles <- ggplot(bootstrap, aes(sample = media)) + geom_qq(distribution = stats::qunif)
g_histograma <- ggplot(bootstrap, aes(x = media)) + geom_histogram(binwidth = 2)
g_cuantiles + g_histograma
```
A esta le llamamos la distribución de remuestreo de la media, que definimos más abajo.
Ahora podemos calcular un intervalo de confianza del 90\% simplemente calculando los cuantiles de
esta distribución (no son los cuantiles de la muestra original!):

```{r}
limites_ic <- quantile(media_muestras, c(0.05,  0.95)) %>% round
limites_ic
```

Presentaríamos nuestro resultado como sigue: nuestra estimación puntual de la mediana es
`r mean(muestra$precio_miles)`, con un intervalo de confianza del 90\% de (`r limites_ic[1]`, `r limites_ic[2]`)

Otra cosa que podríamos hacer para describir la dispersión de nuestro estimador
es calcular el error estándar de remuestreo, que estima el error estándar de
la distribución de muestreo:

```{r}
ee_boot <- sd(media_muestras)
round(ee_boot, 2)
```



```{block2, type='mathblock'}
**Definición**. Sea $X_1,X_2,\ldots,X_n$ una muestra independiente y idénticamente
distribuida, y $T=t(X_1, X_2, \ldots, X_n)$ una estadística. Supongamos que sus valores
que obervamos son $x_1, x_2,\ldots, x_n$.

La **distribución de remuestreo** de $T$ es la
distribución de $T^*=t(X_1^*, X_2^*, \dots X_n^*)$, donde cada $X_i^*$ se obtiene
tomando al azar uno de los valores de $x_1,x_2,\ldots, x_n$.

```

- Otra manera de decir esto es que la remuestra $X_1^*, X_2^*, \ldots, X_n^*$ es una muestra
con reemplazo de los valores observados $x_1, x_2, \ldots, x_n$

**Ejemplo.** Si observamos la muestra 

```{r}
muestra <- sample(1:20, 5)
muestra
```

Una remuestra se obtiene:

```{r}
sample(muestra, size = 5, replace = TRUE)
```
Nótese que algunos valores de la muestra original pueden aparecer varias veces, y otros no aparecen del todo.



```{block2, type='comentario'}
**La idea del bootstrap**. La muestra original es una aproximación de la población
de donde fue extraída. Así que remuestrear la muestra aproxima lo que pasaría si
tomáramos muestras de la población. La **distribución de remuestreo** de una estadística,
que se construye tomando muchas remuestras, aproxima la distribución de muestreo
de la estadística.
```

Y el proceso que hacemos es:

```{block2, type='comentario'}
**Remuestreo para una población.** Dada una muestra de tamaño $n$ de una población, 

1. Obtenemos una remuestra de tamaño $n$ sin reemplazo de la muestra original
2. Repetimos este remuestreo muchas veces (por ejemplo, 10,000).
3. Construímos la distribución bootstrap, y examinamos sus características 
(dónde está centrada, dispersión y forma).
```



## El principio de plug-in {-}

La idea básica detraś del bootstrap es el principio de plug-in para estimar
parámetros poblacionales: si queremos
estimar una cantidad poblacional, calculamos esa cantidad poblacional con la muestra
obtenida. Es un principio común en estadística. 

Por ejemplo, si queremos estimar
la media o desviación estándar poblacional, usamos la media muestral o la desviación
estándar muestral. Si queremos estimar un cuantil de la población usamos el cuantil
correspondiente de la muestra, y así sucesivamente.

En todos estos casos, lo que estamos haciendo es:

- Tenemos una fórmula para la cantidad poblacional de interés en términos de la distribución
poblacional.  
- Tenemos una muestra, que usamos para estimar la cantidad poblacional. La distribución
que da una muestra se llama distribución *empírica**
- Contruimos nuestro estimador "enchufando" la distribución empírica de la muestra 
en la fórmula del estimador.

En el bootstrap aplicamos este principio simple a la **distribución de 
muestreo**:

- *Si tenemos la población*, podemos *calcular* la distribución de muestreo de nuestro estimador
tomando muchas muestras de la *población*.
- Estimamos la *poblacion* con la *muestra* y enchufamos en la frase anterior:
- Podemos *estimar* la distribucion de muestreo de nuestro estimador
tomando muchas muestras de la *muestra* (bootstrap).

Nótese que el proceso de muestreo en el último paso **debe ser el mismo** que
se usó para tomar la muestra original. Estas dos imágenes de @Chihara muestran lo
que acabamos de describir:


```{r mundo-real, warning=FALSE, fig.cap='Mundo Real', echo = FALSE}
library(LaplacesDemon)
library(patchwork)
# En este ejemplo la población es una mezcla de normales
pob_plot <- ggplot(data_frame(x = -15:20), aes(x)) +
  stat_function(fun = dnormm, args = list(p = c(0.3, 0.7), mu = c(-2, 8),
                                          sigma = c(3.5, 3)), alpha = 0.8) +
  geom_vline(aes(color = "mu", xintercept = 5), alpha = 0.5) +
  scale_colour_manual(values = c('mu' = 'red'), name = '', 
                      labels = expression(mu)) +
  scale_y_continuous(breaks = NULL) +
  labs(x = "", subtitle = expression("Población "~F), color = "") +
  theme_classic()

samples <- data_frame(sample = 1:3) %>% 
  mutate(
    sims = rerun(3, rnormm(30, p = c(0.3, 0.7), mu = c(-2, 8), 
                           sigma = c(3.5, 3))), 
    x_bar = map_dbl(sims, mean))
muestras_plot <- samples %>% 
  unnest(cols = c(sims)) %>% 
  ggplot(aes(x = sims)) +
  geom_histogram(binwidth = 2, alpha = 0.5, fill = "darkgray") +
  geom_vline(xintercept = 5, color = "red", alpha = 0.5) +
  geom_segment(aes(x = x_bar, xend = x_bar, y = 0, yend = 0.8), 
      color = "blue") +
  xlim(-15, 20) +
  facet_wrap(~ sample) +
  scale_y_continuous(breaks = NULL) +
  geom_text(aes(x = x_bar, y = 0.95, label = "bar(x)"), parse = TRUE, 
      color = "blue", alpha = 0.2, hjust = 1) +
  labs(x = "", subtitle = "Muestras") +
  theme_classic() +
  theme(strip.background = element_blank(), strip.text.x = element_blank())

samples_dist <- tibble(sample = 1:10000) %>% 
  mutate(sims = rerun(10000, rnormm(100, p = c(0.3, 0.7), mu = c(-2, 8), 
                                    sigma = c(3.5, 3))), 
         mu_hat = map_dbl(sims, mean))
dist_muestral_plot <- ggplot(samples_dist, aes(x = mu_hat)) +
  geom_density(adjust = 2) +
  scale_y_continuous(breaks = NULL) +
  labs(x = "", y = "",
       subtitle = expression("Distribución muestral de "~hat(mu)==bar(X))) +
  geom_vline(xintercept = 5, color = "red", alpha = 0.5) +
  theme_classic()

(pob_plot | plot_spacer()) / (muestras_plot | dist_muestral_plot) 
```


```{r mundo-bootstrap, warning=FALSE, fig.cap='Mundo Bootstrap', echo = FALSE}
dist_empirica <- tibble(id = 1:30, obs = samples$sims[[1]])

dist_empirica_plot <- ggplot(dist_empirica, aes(x = obs)) +
  geom_histogram(binwidth = 2, alpha = 0.5, fill = "darkgray") +
  geom_vline(aes(color = "mu", xintercept = 5), alpha = 0.5) +
  geom_vline(aes(xintercept = samples$x_bar[1], color = "x_bar"), 
             alpha = 0.8, linetype = "dashed") +
  xlim(-15, 20) +
  geom_vline(xintercept = 5, color = "red", alpha = 0.5) +
  labs(x = "", subtitle = expression("Distribución empírica"~hat(F))) +
  scale_colour_manual(values = c('mu' = 'red', 'x_bar' = 'blue'), name = '', 
                      labels = c(expression(mu), expression(bar(x)))) +
  scale_y_continuous(breaks = NULL) +
  theme_classic()

samples_boot <- tibble(sample_boot = 1:3) %>% 
  mutate(
    sims_boot = rerun(3, sample(dist_empirica$obs, replace = TRUE)), 
    x_bar_boot = map_dbl(sims_boot, mean)
  )

muestras_boot_plot <- samples_boot %>% 
  unnest(cols = c(sims_boot)) %>% 
  ggplot(aes(x = sims_boot)) +
  geom_histogram(binwidth = 2, alpha = 0.5, fill = "darkgray") +
  geom_vline(aes(xintercept = samples$x_bar[1]), color = "blue",
             linetype = "dashed", alpha = 0.8) +
  geom_vline(xintercept = 5, color = "red", alpha = 0.5) +
  geom_segment(aes(x = x_bar_boot, xend = x_bar_boot, y = 0, yend = 0.8), 
               color = "black") +
  xlim(-15, 20) +
  facet_wrap(~ sample_boot) +
  geom_text(aes(x = x_bar_boot, y = 0.95, label = "bar(x)^'*'"), 
            parse = TRUE, color = "black", alpha = 0.3, hjust = 1) +
  labs(x = "", subtitle = "Muestras bootstrap") +
  scale_y_continuous(breaks = NULL) +
  theme_classic() +
  theme(strip.background = element_blank(), strip.text.x = element_blank())

boot_dist <- data_frame(sample = 1:10000) %>% 
  mutate(
    sims_boot = rerun(10000, sample(dist_empirica$obs, replace = TRUE)), 
    mu_hat_star = map_dbl(sims_boot, mean))
boot_muestral_plot <- ggplot(boot_dist, aes(x = mu_hat_star)) +
  geom_histogram(alpha = 0.5, fill = "darkgray", bins = 30) +
  labs(x = "", 
       subtitle = expression("Distribución bootstrap de "~hat(mu)^'*'==bar(X))) +
  geom_vline(xintercept = 5, color = "red", alpha = 0.5) +
  geom_vline(aes(xintercept = samples$x_bar[1]), color = "blue", 
             linetype = "dashed", alpha = 0.8) +
  scale_y_continuous(breaks = NULL) +
  theme_classic()

(dist_empirica_plot | plot_spacer()) / (muestras_boot_plot | boot_muestral_plot) 
```


**Observación 1**. Veremos ejemplos más complejos, pero nótese que si la muestra
original son observaciones independientes obtenidas de la distribución poblacional,
entonces logramos esto en las remuestras tomando observaciones con reemplazo
de la muestra. Igalmente, las remuestras deben ser del mismo tamaño que la muestra
original.

```{block2,type='ejercicio'}
- ¿Qué no funcionaría tomar muestras sin reemplazo? Piensa si hay independencia
entre las observaciones de la remuestra, y cómo serían las remuestras sin reemplazo.
- ¿Por qué no se puede hacer bootstrap si no conocemos cómo se obtuvo la muestra original?
```


**Observación 2**. Estos argumentos se pueden escribir con fórmulas usando por
ejemplo la función de distribución acumulada $F$ de la población y su estimador,
que es la función empírica $\hat{F}$, como en @Efron. 
Si $\theta = t(F)$ es una
cantidad poblacional que queremos estimar, su estimador plug-in es
$\hat{\theta} = t(\hat{F})$. 

**Observación 3**: La distribución empírica $\hat{F}$ es un estimador "razonable" de
la distribución poblacional $F,$ pues por el teorema de Glivenko-Cantelli (ver @Wasserman,
o [aquí](https://en.wikipedia.org/wiki/Glivenko-Cantelli_theorem)), 
$\hat{F}$ converge a $F$ cuando el tamaño de muestra $n\to\infty$, lo cual es
intuitivamente claro.



### Ejemplo {-}
En el ejemplo de tomadores de té, podemos estimar la proporción de tomadores
de té que prefiere el té negro usando nuestra muestra:

```{r}
te <- read_csv("data/tea.csv") %>%
  rowid_to_column() %>% 
  select(rowid, Tea, sugar)
te %>% mutate(negro = ifelse(Tea == "black", 1, 0)) %>% 
  summarise(prop_negro = mean(negro), n = length(negro))
```

¿Cómo evaluamos la precisión de este estimador? Supondremos que el estudio se
hizo tomando una muestra aleatoria simple de tamaño 300 de la población de tomadores de té que
nos interesa. Podemos entonces usar el boostrap:

```{r}
# paso 1: define el estimador
calc_estimador <- function(datos){
  prop_negro <- datos %>% 
    mutate(negro = ifelse(Tea == "black", 1, 0)) %>% 
    summarise(prop_negro = mean(negro), n = length(negro)) %>% 
    pull(prop_negro)
  prop_negro
}
# paso 2: define el proceso de remuestreo
muestra_boot <- function(datos){
  #tomar muestra con reemplazo del mismo tamaño
  sample_n(datos, size = nrow(datos), replace = TRUE)
}
# paso 3: remuestrea y calcula el estimador
prop_negro_tbl <- map_dbl(1:2000,  ~ calc_estimador(muestra_boot(datos = te))) %>% 
  tibble(prop_negro = .)
# paso 4: examina la distribución bootstrap
prop_negro_tbl %>% 
  ggplot(aes(x = prop_negro)) +
  geom_histogram(bins = 15)
```

Y podemos evaluar varios aspectos, por ejemplo dónde está centrada y 
qué tan dispersa es la distribución bootstrap:

```{r}
prop_negro_tbl %>% 
  summarise(media = mean(prop_negro),
            sesgo = mean(prop_negro) - 0.2499,
            ee = sd(prop_negro),
            cuantil_75 = quantile(prop_negro, 0.75), 
            cuantil_25 = quantile(prop_negro, 0.25)) %>% 
  mutate(across(where(is.numeric), round, 3)) %>% 
  pivot_longer(cols = everything())
```


## Discusión: propiedades de la distribución bootstrap {-}

Uasremos la distribución bootstrap principalmente para evaluar la variabilidad
de nuestros estimadores (y también otros aspectos como sesgo) estimando
la dispersión de la distribución de muestreo. Sin embargo, es importante notar
que no la usamos, por ejemplo, para saber dónde está centrada la distribución 
de muestreo, o para "mejorar" la estimación remuestreando.

### Ejemplo {-}

En nuestro ejemplo, podemos ver varias muestras (por ejemplo 20) de tamaño 200, y
vemos cómo se ve la aproximación a la distribución de la población:

```{r, echo = FALSE, message = FALSE, fig.width =4, fig.height = 3, cache = TRUE}
set.seed(911)
muestras <- map(1:20, function(x) {
    muestra <- sample_n(poblacion_casas, 200, replace = T) %>% 
        mutate(rep = x, tipo = "muestras")}) %>% bind_rows
dat_pob <- poblacion_casas %>% mutate(tipo = "población", rep = 1)
datos_sim <- bind_rows(dat_pob, muestras)

ggplot(datos_sim, aes(sample = precio_miles, group = interaction(tipo, rep))) + 
    geom_qq(distribution = stats::qunif, alpha = 0.7, size = 0.5, geom = "line") + 
geom_qq(data = dat_pob, aes(sample = precio_miles), colour = "red", size = 1,
        distribution = stats::qunif, geom="point") +
  scale_y_log10(breaks = c(50, 100, 200, 400, 800)) 
```

Podemos calcular las distribuciones de remuestreo para cada muestra bootstrap,
y compararlas con la distribución de muestreo real.

```{r,  fig.width =4, fig.height = 3, cache = TRUE}
# paso 1: define el estimador
calc_estimador <- function(datos){
  media_precio <- datos %>% 
    summarise(media = mean(precio_miles)) %>% 
    pull(media)
  media_precio
}
# paso 2: define el proceso de remuestreo
muestra_boot <- function(datos, n = NULL){
  #tomar muestra con reemplazo del mismo tamaño
  if(is.null(n)){
    m <- sample_n(datos, size = nrow(datos), replace = TRUE)}
  else {
    m <- sample_n(datos, size = n, replace = TRUE)
  }
  m
}
dist_boot <- datos_sim %>%
  filter(tipo == "muestras") %>% 
  select(precio_miles, rep) %>% 
  group_by(rep) %>% nest() %>% 
  mutate(precio_miles =  map(data, function(data){
    tibble(precio_miles = map_dbl(1:1000, ~ calc_estimador(muestra_boot(data))))
  })) %>% 
  select(rep, precio_miles) %>% 
  unnest()
  
dist_muestreo <- datos_sim %>% 
  filter(tipo == "población") %>% 
  group_by(rep) %>% nest() %>% 
  mutate(precio_miles =  map(data, function(data){
    tibble(precio_miles = map_dbl(1:1000, ~ calc_estimador(muestra_boot(data, n = 200))))
  })) %>% 
  select(rep, precio_miles) %>% 
  unnest()
```


```{r, echo = FALSE, fig.width =4, fig.height = 3}
ggplot(dist_boot, aes(sample = precio_miles, group = interaction(rep))) + 
    geom_qq(distribution = stats::qunif, size = 0.1, alpha = 0.1) + 
geom_qq(data = dist_muestreo, aes(sample = precio_miles), colour = "red",
        distribution = stats::qunif, alpha = 0.1) +
  ylim(c(125, 230)) +
  labs(subtitle = "Estimaciones de distribución \n de muestreo (media)")
```

Obsérvese que:

- En algunos casos la aproximación  es mejor que en otros (a veces
la muestra tiene valores ligeramente más altos o más bajos). 
- La dispersión de cada una de estas distribuciones bootstrap es similar a la de la verdadera
distribución de muestreo (en rojo), pero puede está desplazada dependiendo
de la muestra original que utilizamos.
- Adicionalmente, los valores centrales de la distribución de bootstrap
tiende cubrir el verdadero valor que buscamos estimar, que es:

```{r}
poblacion_casas %>% summarise(media = mean(precio_miles))
```


## Error estándar bootstrap e intervalos normales

Ahora podemos construir nuestra primera versión de intervalos de confianza
basados en la distribución bootstrap. 

- Supongamos que queremos estimar una cantidad poblacional $\theta$ con una
estadística $\hat{\theta} = t(X_1,\ldots, X_n)$, donde $X_1,\ldots, X_n$ es una muestra
independiente e idénticamente distribuida de la población.

- Suponemos además que la distribución muestral de $\hat{\theta}$ es aproximadamente normal (el teorema
central del límite aplica), y está centrada en el verdadero valor poblacional $\theta$.

Ahora queremos construir un intervalo que tenga probabilidad 95\% de cubrir al
valor poblacional $\theta$. Tenemos que

$$P(-2\mathsf{ee}(\hat{\theta}) <  \hat{\theta} - \theta < 2\mathsf{ee}(\hat{\theta})) \approx 0.95$$
por las propiedades de la distribución normal ($P(-2\sigma < X -\mu < 2\sigma)\approx 0.95$ si $X$ es
normal con media $\mu$ y desviación estándar $\sigma$). Entonces

$$P(\hat{\theta} - 2\mathsf{ee}(\hat{\theta}) < \theta < \hat{\theta} + 2\mathsf{ee}(\hat{\theta})) \approx 0.95$$
Es decir, la probabilidad de que el verdadero valor poblacional $\theta$ esté en el intervalo
$$[\hat{\theta} - 2\mathsf{ee}(\hat{\theta}), \hat{\theta} + 2\mathsf{ee}(\hat{\theta})]$$
es cercano a 0.95. En este intervalo no conocemos el error estándar (es la desviación estándar
de la distribución de muestreo de $\hat{\theta}$), y aquí es donde
entre la distribución bootstrap, que aproxima la distribución de muestreo. Lo estimamos con

$$\hat{\mathsf{ee}}_{\textrm{boot}}(\hat{\theta})$$
que es la desviación estándar de la **distribución bootsrap**.

```{block2, type='mathblock'}
*Definición*. El **error estándar bootstrap**  $\hat{\mathsf{ee}}_{\textrm{boot}}(\hat{\theta})$ se
define como la desviación estándar de la distribución bootstrap de $\theta$. 

El **intervalo de confianza normal bootstrap** al 95\% está dado por
$$[\hat{\theta} - 2\mathsf{ee}(\hat{\theta}), \hat{\theta} + 2\mathsf{ee}(\hat{\theta})]$$
```

Nótese que hay varias cosas qué checar aquí: que el teorema central del límite aplica y
que la distribución de muestreo de nuestro estimador está centrado en el valor verdadero.
Esto en algunos casos se puede demostrar usando la teoría, pero más abajo veremos
comprobaciones empíricas.


### Ejemplo: tomadores de té negro{-}

Consideremos la estimación que hicimos de el procentaje de tomadores de té que toma
té negro:

```{r}
# paso 1: define el estimador
calc_estimador <- function(datos){
  prop_negro <- datos %>% 
    mutate(negro = ifelse(Tea == "black", 1, 0)) %>% 
    summarise(prop_negro = mean(negro), n = length(negro)) %>% 
    pull(prop_negro)
  prop_negro
}
prop_hat <- calc_estimador(te)
prop_hat %>% round(2)
```

Podemos graficar su distribución bootstrap (simulamos arriba)

```{r, fig.width = 7, fig.height = 4}
g_hist <- ggplot(prop_negro_tbl, aes(x = prop_negro)) + geom_histogram(bins = 15)
g_qq_normal <- ggplot(prop_negro_tbl, aes(sample = prop_negro)) +
  geom_qq() + geom_qq_line(colour = "red")
g_hist + g_qq_normal
```
Y nótese que la distribución bootstrap es aproximadamente normal. Adicionalmente, vemos que 

```{r}
media_boot <- prop_negro_tbl %>% pull(prop_negro) %>% mean
media_boot - prop_hat
```

De forma que el sesgo de la distribución bootstrap es muy chico.

Verificamos que 

- La distribución bootstrap es aproximadamente normal (ver gráfica de cuantiles normales),
. La distribución bootstrap es aproximadamente insesgada,

De forma que podemos usar los intervalos normales para construir un intervalo de 
confianza. Estimamos el error estándar con la desviación estándar de la distribución bootstrap

```{r}
ee_boot <- prop_negro_tbl %>% pull(prop_negro) %>% sd
ee_boot
```

Y construimos un intervalo de confianza del 95%:

```{r}
intervalo_95 <- c(prop_hat - 2 * ee_boot, prop_hat + 2 * ee_boot)
intervalo_95 %>% round(2)
```

Este intervalo tiene probabilidad del 95% de capturar al verdadero poblacional. Con
*alta* probabilidad, entonces, el porcentaje de tomadores de té en la población
está entre `r round(intervalo_95[1], 2)` y `r round(intervalo_95[2], 2)`.

## Ejemplo: inventario de casas vendidas

Ahora consideremos el problema de estimar el total del valor de las casas
vendidas en un periodo. Tenemos una muestra de tamaño $n=150$:

```{r}
# muestra original
set.seed(121)
muestra_casas <- sample_n(poblacion_casas, size = 150)
# paso 1: define el estimador
calc_estimador_casas <- function(datos){
  N <- nrow(poblacion_casas)
  n <- nrow(datos)
  total_muestra <- sum(datos$precio_miles)
  estimador_total <- (N / n) * total_muestra
  estimador_total
}
# paso 2: define el proceso de remuestreo
muestra_boot <- function(datos){
  #tomar muestra con reemplazo del mismo tamaño
  sample_n(datos, size = nrow(datos), replace = TRUE)
}
# paso 3: remuestrea y calcula el estimador
totales_boot <- map_dbl(1:5000,  ~ calc_estimador_casas(muestra_boot(muestra_casas))) %>% 
  tibble(total_boot = .)
# paso 4: examina la distribución bootstrap
g_hist <- totales_boot %>% 
  ggplot(aes(x = total_boot)) +
  geom_histogram()
g_qq <- totales_boot %>%
  ggplot(aes(sample = total_boot)) +
  geom_qq() + geom_qq_line(colour = "red") +
  geom_hline(yintercept = quantile(totales_boot$total_boot, 0.975), colour = "gray") +
  geom_hline(yintercept = quantile(totales_boot$total_boot, 0.025), colour = "gray") 
g_hist + g_qq
```
En este caso, distribución de muestreo presenta cierta asimetría, pero la desviación no es grande.
En la parte central 95% central la aproximación normal es razonable. Checamos sesgo

```{r}
total_est <- calc_estimador_casas(muestra_casas)
sesgo <- mean(totales_boot$total_boot) - total_est
sesgo
```
Este número puede parecer grande, pero sí calculamos la desviación relativa
con respecto al estimador vemos que es chico en la escala de la distribución 
bootstrap:

```{r}
sesgo_relativo <- sesgo / total_est
sesgo_relativo
```

De forma que procedemos a construir intervalos de confianza como sigue :

```{r}
ee_boot <- sd(totales_boot$total_boot)
c(total_est - 2*ee_boot, total_est + 2*ee_boot)
```

Que está en miles de dólares. En millones de dólares, este intervalo es:

```{r}
intervalo_total <- c(total_est - 2*ee_boot, total_est + 2*ee_boot) / 1000
intervalo_total %>% round(1)
```

Así que con 95% de confianza el verdadero total del valor de las casas vendidas
está entre `r round(intervalo_total[1])` y `r round(intervalo_total[2])` millones
de dólares.

**Nota.** en este ejemplo, mostraremos una alternativa de intervalos de confianza
que es más apropiado cuando observamos asimetría.


## Calibración de intervalos de confianza

¿Cómo sabemos que nuestros intervalos de confianza del 95% nominal 
tienen cobertura real de 95\%? Es decir, tenemos que checar:

- El procedimiento para construir intervalos debe dar intervalos tales
que el valor poblacional está en el intervalo de confianza para 95% de las muestras.

Como solo tenemos una muestra, la calibración depende de argumentos teóricos o
estudios de simulación previos. Para nuestro ejemplo de casas tenemos la
población, así que podemos checar qué cobertura real tienen los intervalos normales:

```{r, cache = TRUE}
simular_intervalos <- function(rep, size = 150){
  muestra_casas <- sample_n(poblacion_casas, size = size)
  N <- nrow(poblacion_casas)
  n <- nrow(muestra_casas)
  total_est <- (N / n) * sum(muestra_casas$precio_miles)
  # paso 1: define el estimador
  calc_estimador_casas <- function(datos){
    total_muestra <- sum(datos$precio_miles)
    estimador_total <- (N / n) * total_muestra
    estimador_total
  }
  # paso 2: define el proceso de remuestreo
  muestra_boot <- function(datos){
    #tomar muestra con reemplazo del mismo tamaño
    sample_n(datos, size = nrow(datos), replace = TRUE)
  }
  # paso 3: remuestrea y calcula el estimador
  totales_boot <- map_dbl(1:2000,  ~ calc_estimador_casas(muestra_boot(muestra_casas))) %>% 
    tibble(total_boot = .) %>%
    summarise(ee_boot = sd(total_boot)) %>% 
    mutate(inf = total_est - 2*ee_boot, sup = total_est + 2*ee_boot) %>% 
    mutate(rep = rep)
  totales_boot
}
sims_intervalos <- map(1:100, ~ simular_intervalos(rep = .x))
```

```{r, fig.width =8, fig.height=4}
total <- sum(poblacion_casas$precio_miles)
sims_tbl <- sims_intervalos %>% 
  bind_rows %>%
  mutate(cubre = inf < total & total < sup) 
ggplot(sims_tbl, aes(x = rep)) +
  geom_hline(yintercept = total, colour = "red") +
  geom_linerange(aes(ymin = inf, ymax = sup, colour = cubre)) 
```
La cobertura para estos 100 intervalos simulados da

```{r}
total <- sum(poblacion_casas$precio_miles)
sims_tbl %>% 
  summarise(cobertura = mean(cubre))
```
que es consistente con una cobertura real del 95% (¿qué significa "consistente"? ¿Cómo puedes
checarlo con el bootstrap?)

**Observación.** En este caso teníamos la población real, y pudimos verificar
la cobertura de nuestros intervalos. En general no la tenemos. Estos ejercicios
de simulación se pueden hacer con poblaciones sintéticas simuladas que tengan
las características que creemos va a tener nuestra población (por ejemplo, sesgo,
colas largas, etc.).

```{block2 ,type='comentario'}
En general, no importa qué tipo de estimadores o intervalos de confianza usemos, 
requerimos
checar la calibración. Esto puede hacerse con ejercicios de simulación con poblaciones
sintéticas y tanto los procedimientos de muestreo como 
los tamaños de muestra que nos interesa usar. 
```

Algunos casos son bien entendidos, como estimaciones para poblaciones teóricas particulares,
distribuciones simétricas con colas no muy largas o estimación de proporciones que no
son muy cercanas a 0 o 1, y en estos casos los procedimientos usuales funcionan bien.



## Interpretación de intervalos de confianza

Como hemos visto,  "intervalo de confianza" (de 90\% de confianza, por ejemplo) es un
término frecuentista, que significa:

- **Cada muestra produce un intervalo distinto**. Para el 90\% de las muestras posibles, el intervalo
cubre al valor poblacional.
- Así que con *alta probabilidad*, el valor poblacional está dentro del intervalo.
- Intervalos más anchos nos dan más incertidumbre acerca de dónde está el verdadero valor poblacional
(y al revés para intervalos más angostos).

Existen también "intervalos de credibilidad" (de 90\% de probabilidad, por ejemplo), que se interpetan de
forma bayesiana:

- Con 90\% de probabilidad (relativamente alta), creemos que el valor poblacional está dentro del intervalo de credibilidad.

Esta última interpretación es más natural. Obsérvese que para hablar de intervalos de
confianza frecuentista tenemos que decir:

- Este intervalo particular cubre o no al verdadero valor, pero nuestro procedimiento produce intervalos
que para 90\% de las muestras. 
- Esta es una interpretación relativamente débil, y muchos intervalos poco útiles pueden satisfacerla
- La interpretación bayesiana es más natural porque expresa más claramente incertidumbre acerca
del valor poblacional.

Por otro lado,

- La interpretación frecuentista nos da maneras empíricas de probar si los intervalos de
confianza están bien calibrados o no: es un mínimo que "intervalos del 90\%" deberían satisfacer.

Así que tomamos el punto de vista bayesiano en la intepretación, pero 
buscamos que nuestros intervalos cumplan o 
aproximen bien garantías frecuentistas (discutimos esto más adelante). Los intervalos
que producimos en esta sección pueden interpretarse de las dos maneras.


## Intervalos bootstrap de percentiles {-}

Otra opción común que se usa específicamente cuando la distribución bootstrap 
no es muy cercana a la normal son los intervalos de percentiles bootstrap:

```{block2, type='mathblock'}
*Definición*. El **intervalo de percentiles bootstrap** al 95\% de confianza
está dado por
$$[q_{0.025}, q_{0.975}]$$
donde $q_f$ es el percentil $f$ de la distribución bootstrap. 
```

Otros intervalos comunes son el de 80% o 90% de confianza, por ejemplo,
que corresponden a $[q_{0.10}, q_{0.90}]$ y $[q_{0.05}, q_{0.95}]$. *Ojo*: 
intervalos de confianza muy alta (por ejemplo 99.5%) pueden tener mala calibración
o ser muy variables en su longitud pues dependen del comportamiento en las colas de la
distribución.

### Ejemplo {-}

Para el ejemplo de las casas, calcularíamos simplemente

```{r}
intervalo_95 <- totales_boot %>% pull(total_boot) %>% quantile(., probs = c(0.025, 0.975))
(intervalo_95 / 1000) %>% round(1)
```
que está en millones de pesos. Nótese que es similar al intervalo de error estándar.

```{block2, type='ejercicio'}
Explica por qué cuando la aproximación normal es apropiada, el intervalo de percentiles
al 95% es muy similar al intervalo normal de 2 errores estándar.
```

### Ejemplo {-}

Consideramos los datos de propinas. Queremos estimar la media de cuentas
totales para la comida y la cena. Podemos hacer bootstrap de cada grupo
por separado:

```{r}
# en este ejemplo usamos rsample, pero puedes
# escribir tu propio código
library(rsample)
propinas <- read_csv("data/propinas.csv")
estimador <- function(split, ...){
  muestra <- analysis(split) %>% group_by(momento)
  muestra %>% 
    summarise(estimate = mean(cuenta_total)) %>% 
    mutate(term = momento)
}
intervalo_propinas_90 <- bootstraps(propinas, strata = momento, 1000) %>% 
  mutate(res_boot = map(splits, estimador)) %>% 
  int_pctl(res_boot, alpha = 0.10) %>% 
  mutate(across(where(is.numeric), round, 2))
intervalo_propinas_90
```

Nota: *.estimate* es la media de los valores de la estadística sobre las remuestras, **no** es
el estimador original.

De la tabla anterior inferimos que la media en la cuenta en la cena es más grande que la de la comida.
Podemos graficar agregando los estimadores plugin:

```{r}
estimadores <- propinas %>% 
  group_by(momento) %>% 
  rename(term = momento) %>% 
  summarise(media = mean(cuenta_total))

ggplot(intervalo_propinas_90, aes(x = term)) +
  geom_linerange(aes(ymin = .lower, ymax = .upper)) +
  geom_point(data = estimadores, aes(y = media), colour = "red", size = 3) +
  xlab("Momento") + ylab("Media de cuenta total (dólares)") +
  labs(subtitle = "Intervalos de 90% para la media")
```

Nótese que el bootstrap lo hicimos por separado en cada momento del día (por eso
el argumento *strata* en la llamada a **bootstraps**):

```{block2, type='ejercicio'}
Justifica el procedimiento de hacer el bootstrap separado para cada grupo. ¿Qué supuestos
acerca del muestreo se deben satisfacer? ¿Deben ser muestras aleatorias simples 
de cada momento del día, por ejemplo? ¿Qué harías si no fuera así, por ejemplo, si 
se escogieron al azar tickets de todos los disponibles en un periodo?
```








